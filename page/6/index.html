<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/not_advanced_ins.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/not_advanced_ins.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/not_advanced_ins.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/not_advanced_ins.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/not_advanced_ins.github.io/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"alberteuler.github.io","root":"/not_advanced_ins.github.io/","images":"/not_advanced_ins.github.io/images","scheme":"Muse","version":"8.5.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/not_advanced_ins.github.io/js/config.js"></script>
<meta name="description" content="更不更新看心情">
<meta property="og:type" content="website">
<meta property="og:title" content="不先进摸鱼研究所">
<meta property="og:url" content="https://alberteuler.github.io/not_advanced_ins.github.io/page/6/index.html">
<meta property="og:site_name" content="不先进摸鱼研究所">
<meta property="og:description" content="更不更新看心情">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Albert -W">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alberteuler.github.io/not_advanced_ins.github.io/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>不先进摸鱼研究所</title>
  




  <noscript>
    <link rel="stylesheet" href="/not_advanced_ins.github.io/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/not_advanced_ins.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">不先进摸鱼研究所</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">在hexo上的分站</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/not_advanced_ins.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/not_advanced_ins.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/not_advanced_ins.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/not_advanced_ins.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/not_advanced_ins.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-schedule"><a href="/not_advanced_ins.github.io/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/not_advanced_ins.github.io/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/not_advanced_ins.github.io/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Albert -W"
      src="/not_advanced_ins.github.io/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Albert -W</p>
  <div class="site-description" itemprop="description">更不更新看心情</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/not_advanced_ins.github.io/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/not_advanced_ins.github.io/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/not_advanced_ins.github.io/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:jackwjiong@126.com" title="E-Mail → mailto:jackwjiong@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/26/memeory-note-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/26/memeory-note-2/" class="post-title-link" itemprop="url">分页技术及其原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-26 19:05:46" itemprop="dateCreated datePublished" datetime="2021-06-26T19:05:46+08:00">2021-06-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-28 09:55:04" itemprop="dateModified" datetime="2021-06-28T09:55:04+08:00">2021-06-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>分页存储的基本思想： 把内存分成一个一个相等的小分区，再按照分区大小把进程拆分成一个个小部分<br>以下是一些基本概念：    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>概念</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>页框</td>
<td>将内存空间分成的一个个大小相等的分区</td>
</tr>
<tr>
<td>页框号</td>
<td>每个页框的编号，从0开始</td>
</tr>
<tr>
<td>页</td>
<td>用户进程的地址空间被划分成的，与页框大小相等的区域</td>
</tr>
<tr>
<td>页号</td>
<td>页面的编号，也从0开始</td>
</tr>
</tbody>
</table>
</div>
<p>进程的最后一个页面可能没有页框那么大。页框不能太大，否则可能会产生太大的内部碎片。页框不能太大，否则会产生太大的内部碎片。<br>操作系统一页框为单位为各个进程分配内存空间。进程的每个页面分别放入页框当中。也就是说，进程的页面和内存的页面具有一一对应的关系。        </p>
<p>动态重定位方式——重定位寄存器    </p>
<p><strong>地址如何转换？</strong></p>
<ol>
<li>算出逻辑地址对应的页号</li>
<li>算出页号在页面内存中的起始地址</li>
<li>算出逻辑地址在页面内的偏移量</li>
<li>物理地址 = 页面起始地址+页面偏移量</li>
</ol>
<p>计算方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">页号 = 逻辑地址 / 页面场地</span><br><span class="line">页内偏移量 = 逻辑地址 % 页面长度</span><br><span class="line">逻辑地址 = [页号，页内偏移量]</span><br><span class="line">页面长度一般会是2 的整数次幂</span><br></pre></td></tr></table></figure></p>
<h2 id="页表的概念"><a href="#页表的概念" class="headerlink" title="页表的概念"></a>页表的概念</h2><p>为了能够知道进程的每个页面在内存中的存放位置，操作系统需要为每个进程建立一张页表。</p>
<p>特性：</p>
<ol>
<li>一个进程对应一张页表</li>
<li>进程的每一页对应一个页表项</li>
<li>每个页表项由页号和页框号组成</li>
<li>页表记录了进程页面和实际存放的页框之间的对应关系</li>
</ol>
<p><strong>页表项的长度是相同的，但页号是隐含的。</strong>只需要知道页表存放的起始地址和页表项的长度，就可以找到各个页号对应的页表项存放的位置。</p>
<h1 id="变换机构"><a href="#变换机构" class="headerlink" title="变换机构"></a>变换机构</h1><h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><p>用于实现逻辑地址到物理地址之间的转换的机构。<br>系统当中一般有一个页表寄存器，用来存放页表在内存中的起始地址和页表的长度，进程没有执行的时候，页表的起始地址和页表的长度会放在PCB中，进程被调度的时候，才做系统内核会将之存放到页表寄存器中。</p>
<p>整体过程如下：</p>
<ol>
<li>根据逻辑地址计算出页号、页内偏移量</li>
<li>判断页号是否越界</li>
<li>查询页表，并找到页号对应的页表项，确定页面存放的页框号</li>
<li>通过页框号和页内偏移量计算得到物理地址。</li>
</ol>
<p>例如：</p>
<p>页面大小为L，逻辑地址A到物理地址E的变换过程：</p>
<ol>
<li>计算页号P和页内偏移量W。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P = A/L;</span><br><span class="line">W = A%W;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据页号P和页表长度M判断是否越界<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(P&gt;=M)&#123;</span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查询页表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PT = PT.begin +PT.number * len;</span><br><span class="line"><span class="comment">//页表项地址 = 页表起始地址+页号*页表项长度</span></span><br></pre></td></tr></table></figure>
<ol>
<li>计算物理地址<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = PT;</span><br><span class="line">E = b * L +W;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>页式管理中的地址是一维的。</p>
<h2 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h2><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><div class="table-container">
<table>
<thead>
<tr>
<th>局部性原理</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间局部性</td>
<td>执行了程序中的某条指令，那么该指令不久后可能会被再次执行；数据被访问过，这个数据可能还会被访问过。</td>
</tr>
<tr>
<td>空间局部性</td>
<td>某个存储单元被访问过，其附近的存储单元也有可能会被访问。</td>
</tr>
</tbody>
</table>
</div>
<p>由于局部性原理，某个页表项可能会被连续很多次查到。</p>
<h3 id="块表的概念"><a href="#块表的概念" class="headerlink" title="块表的概念"></a>块表的概念</h3><p><strong>快表</strong>也称联想寄存器（TLB），是一种访问速度逼内存块很多的高速缓存。用来存放当前访问的若干页表项，以加速地址变换的过程。相应地，内存中的页表便称为<strong>慢表</strong>。<br>根据局部性原理，快表会存储最近访问过的页表和对应页框号。</p>
<h3 id="引入块表后地址的映射过程"><a href="#引入块表后地址的映射过程" class="headerlink" title="引入块表后地址的映射过程"></a>引入块表后地址的映射过程</h3><p>引入快表之后，会现在快表中进行查询，如果查询得到对应的页表号（或称为<strong>命中</strong>），那么可以直接根据页号和页框号计算得到物理地址。否则，就需要访问内存（<strong>慢表</strong>），继续查询页框号。</p>
<ol>
<li>CPU给出逻辑地址，计算得到页号和页内偏移量，将页号和快表中的页号进行比较。</li>
<li>找到了匹配的页号（快表命中），直接查询得到对应的内存块号，并由此计算得到物理地址即可。<strong>这个时候只需要一次访存即可</strong></li>
<li>如果没有命中，那么在内存中查询内存块号，由此计算物理地址。<strong>这个时候需要两次访存</strong>，需要访问一次快表和一次慢表</li>
<li>在找到页表项之后，应该同时将其存入快表，以便后面可能发生的再次访存。如果快表已满，则需要进行快表的更新。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th>机构</th>
<th>访问一个逻辑地址需要的访存次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本地址变换机构</td>
<td>两次访存</td>
</tr>
<tr>
<td>具有快表的地址变换机构</td>
<td>若命中为一次访存，未命中为两次访存</td>
</tr>
</tbody>
</table>
</div>
<h1 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h1><h2 id="单级页表的问题"><a href="#单级页表的问题" class="headerlink" title="单级页表的问题"></a>单级页表的问题</h2><ol>
<li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li>
<li>根据局部性原理，没有必要让整个页表常驻内存。</li>
</ol>
<p>一种解决方法是，可以再建立一层页表，叫做页目录表，用来描述各个耳机页表之间的页表号和对应二级页表的地址的关系。</p>
<h2 id="原理和逻辑地址结构"><a href="#原理和逻辑地址结构" class="headerlink" title="原理和逻辑地址结构"></a>原理和逻辑地址结构</h2><p>将一个孤立的大页表拆分程数个小页表，再用一个<strong>页目录表</strong>建立小页表的索引关系。<br>这样地址结构如下：<br>31…22|21…12|11…0<br>—-|—-|—-<br>一级页号|二级页号|页内偏移量</p>
<h2 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h2><ol>
<li>按照地址结构将逻辑地址拆分成三个部分</li>
<li>从PCB中读取页目录表初始地址，然后根据以及页号查页目录表</li>
<li>根据二级页号查表，找到最终项访问的内存块号</li>
<li>结合页内偏移量得到物理地址</li>
</ol>
<h2 id="几个细节"><a href="#几个细节" class="headerlink" title="几个细节"></a>几个细节</h2><ol>
<li>若采用多级页表机制，各级页表的大小不能超过一个页面</li>
<li>不含快表机构的N级页表，其访存次数为N+1次。如果采用了快表，就可以省下至少一次访存次数。</li>
</ol>
<h2 id="基本分段存储"><a href="#基本分段存储" class="headerlink" title="基本分段存储"></a>基本分段存储</h2><h3 id="分段的概念"><a href="#分段的概念" class="headerlink" title="分段的概念"></a>分段的概念</h3><p>将进程的地址空间按照自身的逻辑关系分为多个若干个段，每个段都有一个段名（由程序员决定—），每段都从0开始编址</p>
<p>分段系统的逻辑地址由段号和段内地址构成：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>31…16</th>
<th>15…0</th>
</tr>
</thead>
<tbody>
<tr>
<td>段号</td>
<td>段内地址</td>
</tr>
</tbody>
</table>
</div>
<p>短号的位数绝顶了每个进程最多可以分极端，段内地址的位数决定了每个段的最大长度是多少。</p>
<h3 id="段表的概念"><a href="#段表的概念" class="headerlink" title="段表的概念"></a>段表的概念</h3><p>进程段的位置与物理内存之间的映射表。</p>
<h3 id="地址变换机制"><a href="#地址变换机制" class="headerlink" title="地址变换机制"></a>地址变换机制</h3><h3 id="与分页管理的关系"><a href="#与分页管理的关系" class="headerlink" title="与分页管理的关系"></a>与分页管理的关系</h3><ol>
<li>页是信息的物理单位，对用户是不可见的</li>
<li>段是信息的逻辑单位，分段对用户是可见的。</li>
<li>分页的用户进程是一维的。</li>
<li>分段的用户进程是二维的。</li>
</ol>
<h2 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h2><h3 id="分页和分段管理的优缺点分析"><a href="#分页和分段管理的优缺点分析" class="headerlink" title="分页和分段管理的优缺点分析"></a>分页和分段管理的优缺点分析</h3><div class="table-container">
<table>
<thead>
<tr>
<th>管理模式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分页管理</td>
<td>内存空间利用率高，不产生外部碎片</td>
<td>不方便按照逻辑模块实现西悉尼的共享保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>方便按照逻辑模块实现信息的共享保护</td>
<td>段擦汗给你过大，为其分配很大的连续空间不方便，段式管理会产生外部碎片。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="段页式管理的概念"><a href="#段页式管理的概念" class="headerlink" title="段页式管理的概念"></a>段页式管理的概念</h3><p>基本思想：将进程按照逻辑模块分段，再将各段分页，再将内存空间分为大小相同的内存块。进程钱将各个页面分别装入各个内存块中。</p>
<h3 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h3><div class="table-container">
<table>
<thead>
<tr>
<th>31…16</th>
<th>15…12</th>
<th>11…0</th>
</tr>
</thead>
<tbody>
<tr>
<td>段号</td>
<td>页号</td>
<td>页内偏移量</td>
</tr>
</tbody>
</table>
</div>
<h3 id="段表和页表"><a href="#段表和页表" class="headerlink" title="段表和页表"></a>段表和页表</h3><p>段号、页表长度、页表存放块号。<br>每个段表项的长度相等，段号是隐含的。</p>
<h3 id="地址转换机制"><a href="#地址转换机制" class="headerlink" title="地址转换机制"></a>地址转换机制</h3><ol>
<li>根据逻辑地址得到段号、页号、页内偏移量</li>
<li>判断段号是否越界</li>
<li><strong>在段表内查询段表项</strong>(第一次访存)</li>
<li>判断页号是否越界</li>
<li>根据页表存放块号，页号查询页表，找到对应页表项</li>
<li><strong>根据内存块号，业内偏移量得到最终的物理地址</strong>（第二次访存）</li>
<li><strong>访问目标内存单元</strong>（第三次访存）</li>
</ol>
<p>在这样一个地址转换机制当中，发生了三次访存。如果引入快表机制，用段号和页号作为快表关键字，那么就只需要至少一次访存。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/26/process-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/26/process-note/" class="post-title-link" itemprop="url">进程、线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-26 16:54:17 / Modified: 17:01:24" itemprop="dateCreated datePublished" datetime="2021-06-26T16:54:17+08:00">2021-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>包含内容：</p>
<ol>
<li>创建新进程</li>
<li>撤销已有进程</li>
<li>实现进程状态的转换<br>包含五个态：</li>
<li>创建态</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
<li>终止态</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="原语操作"><a href="#原语操作" class="headerlink" title="原语操作"></a>原语操作</h3><p>控制不允许被中断，只能一气呵成，这是原子的。透过关中断和开中断指令实现。<br>只允许核心态下执行。<br>包含内容：</p>
<ol>
<li>更新PCB信息<ol>
<li>修改进程状态标志</li>
<li>剥夺当前运行进程的CPU使用权，保存其运行环境</li>
<li>进程开始运行前要回复其运行环境</li>
</ol>
</li>
<li>将PCB插入到合适的队列</li>
<li>分配和回收资源</li>
</ol>
<h3 id="进程的控制过程"><a href="#进程的控制过程" class="headerlink" title="进程的控制过程"></a>进程的控制过程</h3><h4 id="进程的开始"><a href="#进程的开始" class="headerlink" title="进程的开始"></a>进程的开始</h4><ol>
<li>创建原语<ol>
<li>申请空白PCB</li>
<li>为新的进程分配所需的资源</li>
<li>初始化PCB</li>
<li>将PCB插入到就绪队列</li>
</ol>
</li>
<li>近期进程的创建的事件<ol>
<li>用户的登录</li>
<li>作业的调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
</li>
</ol>
<h4 id="进程的终止操作"><a href="#进程的终止操作" class="headerlink" title="进程的终止操作"></a>进程的终止操作</h4><ol>
<li>撤销原语<ol>
<li>从PCB集合中找到终止进程的PCB</li>
<li>剥夺CPU并分配给其他进程</li>
<li>终止其所有子进程——或者会被Init进程收养</li>
<li>进程资源归还给父进程或是操作系统</li>
<li>删除PCB</li>
</ol>
</li>
<li>引起进程终止的事件<ol>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ol>
</li>
</ol>
<h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h4><p>阻塞：</p>
<p>唤醒：</p>
<p>阻塞和唤醒必须成对使用，进程因何被阻塞，就应该因何被唤醒。</p>
<h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><p>会让就绪态切换到阻塞态，或者阻塞态切换到运行态。</p>
<h1 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h1><p>各个进程拥有独立的内存地址空间，因此进程之间拥有的内存地址空间是相互独立的<br>进程之间是不能相互访问内存空间的</p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>操作系统为两个进程开辟一个共享的空间。这两个进程必须要互斥地访问这个共享的空间</p>
<ol>
<li>基于数据结构的共享——很慢，格式受限，低级通信方式</li>
<li>基于存储区的共享——速度更快，高级的通信方式</li>
</ol>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>进程间的数据以格式化的消息为单位。进程透过系统提供的发送/接受消息两个原语进行数据的交换。</p>
<ol>
<li>直接通信方式：直接挂到接受形成的消息缓冲队列上</li>
<li>间接通信方式：消息会被发送到一个中间实体上。或者叫信箱通信方式。</li>
</ol>
<h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>一种特殊的共享文件，是内存当中开辟的一个大小固定的缓冲区<br>管道是半双工的，某一时间段内只能实现单项的传输。如果想实现全双工，那么需要设置两个管道。<br>各个进程需要互斥地访问管道。<br>数据将以字符流的形式写入管道。管道写满时，写进程被阻塞；管道空时，读进程被阻塞。<br>如果没写满，就不允许读；如果没读空，就不允许写。<br>读进程最多只有一个。</p>
<h1 id="线程何多线程模型"><a href="#线程何多线程模型" class="headerlink" title="线程何多线程模型"></a>线程何多线程模型</h1><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>在并发的场景当中，引入了线程的概念作为程序执行流的最小单位，使得程序可以在一段时间内做不同的事情。      线程是一种轻量级的进程，<strong>是基本的CPU的执行单元，也是程序执行流的最小单位</strong><br>相对应的，进程是<strong>系统资源调配的执行单元</strong>，但不是基本的CPU执行单元。<br>进程下的各个线程是共享自进程的内存的。</p>
<ol>
<li>资源分配和调度：进程是资源分配的基本单位，线程是CPU调度的基本单位。</li>
<li>并发性：引入线程后，线程之间可以并发</li>
<li>系统开销：引入线程后，并发所带来的系统开销减少了。</li>
</ol>
<h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><ol>
<li>线程是处理机的调度单位</li>
<li>多CPU计算机中各个线程可以占据不同的CPU</li>
<li>和进程类似，每个线程具有一个<strong>ID</strong>和一个<strong>TCB</strong></li>
<li>线程具有就绪、阻塞、运行三个基本太</li>
<li>线程几乎不具有系统资源</li>
<li>同一进程的不同线程间具有共享进程的资源</li>
<li>由于共享内存地址空间，线程间通信不需要系统干预</li>
<li>同意进程中的线程切换不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销较小</li>
<li>切换进程，系统开销较大</li>
</ol>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>线程对用户是不透明的，对操作系统透明，在用户的视角可以看到</p>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>线程的管理过程右操作系统完成，对用户透明，但对操作系统不透明<br>因为用户及线程是对操作系统是透明的，所以操作系统只能接管内核级 线程。只有内核级线程才是处理及分配的单位</p>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>描述用户级线程和内核级线程之间的关系。</p>
<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>线程管理成本开销效率较高<br>但是如果一个 线程阻塞会导致所有的 线程都阻塞</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>可以在多核处理机上并行执行<br>但线程管理成本较高 ，因为涉及到内核级线程的切</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>线程库</p>
<h1 id="处理调度的概念何层次"><a href="#处理调度的概念何层次" class="headerlink" title="处理调度的概念何层次"></a>处理调度的概念何层次</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>决定许多任务的处理顺序</p>
<h2 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h2><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p>作业调度：按照一定的原则提取一个或者多个 队列，建立相应的进程，以便他们获得竞争处理及的权利。<br>他是内存和外村之间的调度，每个作业只调入一次，调出一次，作业调入时会建立PCB，调出时会撤销PCB。</p>
<h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>引入虚拟内存技术后，可以将暂时不能运行的进程调度到外村等待，等它重新 具备了运行条件，且内存 有所空闲时，再重新调入内存。<br>提高了内存的运行利用率和系统吞吐量<br>暂时调度到外存的进程成为挂起状态，PCB不会被调度到外存，二十常驻内存，此时PCB会记录进程数据再外村中的存放位置。被挂起的PCB会放到挂起队列 当中去。<br>中级调度发生的频率要大于高级调度。<br>五状态和七状态模型。<br>挂起也分为两种：</p>
<ol>
<li>就绪挂起</li>
<li>阻塞挂起<br>就绪挂起和阻塞挂起之间存在区别。就绪挂起只是将进程的影响调度到了外存当中，但阻塞态下进程 影响还在内存当中。二者可能会在不同的队列当中。</li>
</ol>
<h3 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h3><p>其主要任务是将处理机分配给 一个进程。频率最高 。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>调度层次</th>
<th>任务</th>
<th>发生场合</th>
<th>发生频率</th>
<th>对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度</td>
<td>从后背队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td>外存-&gt;内存</td>
<td>低</td>
<td>无-&gt;创建态-&gt;内存态</td>
</tr>
<tr>
<td>中级调度</td>
<td>从挂起队列 中选择合适的进程将其调入内存</td>
<td>外存-&gt;内存</td>
<td>中</td>
<td>挂起态-&gt;就绪态</td>
</tr>
<tr>
<td>低级调度</td>
<td>从就绪队列中选择一个进程为其分配处理机</td>
<td>内存-&gt;CPU</td>
<td>高</td>
<td>就绪态-&gt;运行态</td>
</tr>
</tbody></table>
<h1 id="进程调度的时机，切换何过程"><a href="#进程调度的时机，切换何过程" class="headerlink" title="进程调度的时机，切换何过程"></a>进程调度的时机，切换何过程</h1><h2 id="进程合适调度"><a href="#进程合适调度" class="headerlink" title="进程合适调度"></a>进程合适调度</h2><ol>
<li>需要进行进程的调度和切换<ol>
<li>主动放弃<ol>
<li>进程正常终止</li>
<li>运行过程中发生异常</li>
<li>进程主动请求阻塞</li>
</ol>
</li>
<li>被动放弃<ol>
<li>进程的时间片用完</li>
<li>有更紧急的事情 需要处理</li>
<li>有更高 优先级的进程进入就绪队列</li>
</ol>
</li>
</ol>
</li>
<li>不能能进行进程的调度和切换<ol>
<li>处理中断</li>
<li>进程在操作系统的内核程序临界区</li>
<li>原语操作中<br>临界资源：各个进程需要互斥地访问临界资源<br>临界区：访问丽娜姐资源的代码——一般 用于访问某种内核的数据，例如 进程的就绪队列</li>
</ol>
</li>
</ol>
<h2 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h2><ol>
<li>非剥夺的调度方式——非抢占的——只能主动放弃调度</li>
<li>剥夺的调度方式——抢占的——操作系统剥夺进程CPU使用权</li>
</ol>
<h2 id="进程切换的过程"><a href="#进程切换的过程" class="headerlink" title="进程切换的过程"></a>进程切换的过程</h2><ol>
<li>旧进程的数据保存</li>
<li>新进程的数据恢复</li>
</ol>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用率 = 忙碌时间 / 总时间；</span><br></pre></td></tr></table></figure>

<h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 总共完成了多少道作业  / 总共花了多少时间;</span><br></pre></td></tr></table></figure>

<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>概念： 从昨夜被提交给系统开始，到作业完成为止的这段时间间隔</p>
<h4 id="周转时间和平均周转时间"><a href="#周转时间和平均周转时间" class="headerlink" title="周转时间和平均周转时间"></a>周转时间和平均周转时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">周转时间  = 作业完成时间 - 作业提交时间</span><br></pre></td></tr></table></figure>

<p>用户更加关心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均周转时间= 各个作业周转时间总和/ 作业总数</span><br></pre></td></tr></table></figure>

<p>操作系统更加关心</p>
<h4 id="带权周转时间和平均带权周转时间"><a href="#带权周转时间和平均带权周转时间" class="headerlink" title="带权周转时间和平均带权周转时间"></a>带权周转时间和平均带权周转时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">带权时间=周转时间/作业实际运行时间 </span><br></pre></td></tr></table></figure>

<h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><p>进程/作业 处于等待处理机状态时间总和。等待时间越长，用户满意度越低。<br>进程</p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>用户提交到首次产生相应所需的时间。</p>
<h2 id="FCFS-SJF和HRRN调度算法"><a href="#FCFS-SJF和HRRN调度算法" class="headerlink" title="FCFS,SJF和HRRN调度算法"></a>FCFS,SJF和HRRN调度算法</h2><h3 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS:先来先服务"></a>FCFS:先来先服务</h3><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>公平的角度考虑</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><h3 id="SJF：短作业优先"><a href="#SJF：短作业优先" class="headerlink" title="SJF：短作业优先"></a>SJF：短作业优先</h3><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h1 id="同步、互斥"><a href="#同步、互斥" class="headerlink" title="同步、互斥"></a>同步、互斥</h1><h2 id="同步：进程制约的"><a href="#同步：进程制约的" class="headerlink" title="同步：进程制约的"></a>同步：进程制约的</h2><p>为了完成某个任务而建立的两个或者读个进程</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>资源共享方式：1， 互斥共享、2.同时共享</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;</span><br><span class="line">    critial section;</span><br><span class="line">    exit section;</span><br><span class="line">    remiander section;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h2 id="互斥的软件实现方法"><a href="#互斥的软件实现方法" class="headerlink" title="互斥的软件实现方法"></a>互斥的软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>两个进程访问完临界区后，会把使用临界区的权限转交给另外一个进程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//P0:</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn  = <span class="number">1</span>;</span><br><span class="line">remiander section;</span><br><span class="line"><span class="comment">//p1:</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>两个进程是轮流进入临界区的。</p>
<h3 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">2</span>];</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>设置一个<code>vector<bool> flag</code>，用来标记各个进程是否回进入临界区。每个进程在进入临界区时都会检查当前是否有其他进程进入临界区，如果没有则令<code>flag[i] = true</code>,再去进行访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">bool</span>&gt; flag;</span><br><span class="line"><span class="comment">//p i :</span></span><br><span class="line"><span class="keyword">if</span>(flag[<span class="keyword">else</span>])&#123;</span><br><span class="line">    critical section;</span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法的问题时，会违反忙则等待的原则。进入去的检查和上锁并不是一次完成的，违反了原语原则。</p>
<h3 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h3><p>先上锁，后检查。<br>但又违反了空闲让进和有限等待的原则，会因为各个进程都长期无法访问临界资源而产生饥饿现象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt;  <span class="title">flag</span><span class="params">(<span class="number">2</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="comment">//Process P0:</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical sectionl;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//Process P1:</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remiander section;</span><br></pre></td></tr></table></figure>

<p>如果这两个进程是同时进行的，那么双方都会以对方上锁为由无法进入进程，造成进程的饥饿。</p>
<h3 id="peterson法"><a href="#peterson法" class="headerlink" title="peterson法"></a>peterson法</h3><p>如果双方都希望进入临界区，那么就会让对方使用临界区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">2</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> turn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//process P0:</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn==<span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//process P1:</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn==<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<h2 id="互斥的硬件实现方法"><a href="#互斥的硬件实现方法" class="headerlink" title="互斥的硬件实现方法"></a>互斥的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p>利用开-管中断指令实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">关中断；//不允许当前进程中断，也必然不会发生进程切换</span><br><span class="line">临界区；</span><br><span class="line">开中断；</span><br><span class="line">/*</span><br><span class="line">直到当前进程访问完临界区，</span><br><span class="line">再只进行开中断指令，才有可</span><br><span class="line">能再有别的进程上处理机并访</span><br><span class="line">问临界区</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ul>
<li>简单高效</li>
<li>但不适用于多处理及，只适用于内核进程，因为这个指令只能运行在内核态。</li>
</ul>
<h3 id="TestAndSet-TS和TSL指令"><a href="#TestAndSet-TS和TSL指令" class="headerlink" title="TestAndSet - TS和TSL指令"></a>TestAndSet - TS和TSL指令</h3><p>在硬件的级别上实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old  = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;lock));</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">lock = <span class="literal">false</span>; <span class="comment">//解锁</span></span><br><span class="line"><span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure>

<p>这个操作把上锁和检查的过程原子化了。这里不会产生异步现象。适用于多处理机环境。<br>但不满足让权等待的原则。无法进入临界区的进程会虚幻执行TSL指令，从而导致忙等现象。</p>
<h3 id="swap-XCHG指令"><a href="#swap-XCHG指令" class="headerlink" title="swap/XCHG指令"></a>swap/XCHG指令</h3><p>也是在硬件层面上被实现的。它和TSL指令相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;old ,&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">- 实现简单</span><br><span class="line">- 和TSL指令一样，不满足让权等待原则，程序也有可能会不断执行swap操作，导致忙等。</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure>

<h1 id="信号量及其实现"><a href="#信号量及其实现" class="headerlink" title="信号量及其实现"></a>信号量及其实现</h1><h2 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h2><ol>
<li>整形信号量</li>
<li>记录型信号量<br>信号量式一种变量，用来表示系统中某种资源的数量。<br>用户可以透过使用操作系统提供的原语来对信号量进行操作，从而实现了进程互斥、同步。客服了前面提到的几种操作的进入、退出的过程无法原子化实现的问题。<br>这一对原语是： wait(S) 和signal(s),也称为PV(Proberen-Verhogen)操作。</li>
</ol>
<h2 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h2><p>用来表示系统中某种资源的数量。<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>;      <span class="comment">//假设系统中只有一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S&lt;=<span class="number">0</span>);<span class="comment">//无资源时则继续循环等待</span></span><br><span class="line">    S --;       <span class="comment">//占用资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">    S ++;       <span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进程中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S);    <span class="comment">//进入</span></span><br><span class="line"><span class="comment">//使用打印机资源    //临界</span></span><br><span class="line"><span class="built_in">signal</span>(S);<span class="comment">//退出</span></span><br></pre></td></tr></table></figure>

<h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;      <span class="comment">//剩余资源数</span></span><br><span class="line">    process *L;     <span class="comment">//等待队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原语的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">block</span>(S.L);</span><br><span class="line">        <span class="comment">//如果剩余资源不够，那么将进程转入阻塞态，并挂到S.的等待队列中。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value ++ ;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(S.L);</span><br><span class="line">        <span class="comment">//如果释放资源后仍然不足，那么就从等待队列中唤醒一个进程。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S);</span><br><span class="line"><span class="comment">//使用资源</span></span><br><span class="line"><span class="built_in">signal</span>(S);</span><br></pre></td></tr></table></figure>

<p>这对原语可以用于实现系统资源的申请和释放。这是一个使用的信号量机制，遵循了让权等待原则，不会出现忙等现象。<br>同时也可以实现进程互斥地使用资源。</p>
<h2 id="基于信号量机制的进程互斥、同步、前驱关系"><a href="#基于信号量机制的进程互斥、同步、前驱关系" class="headerlink" title="基于信号量机制的进程互斥、同步、前驱关系"></a>基于信号量机制的进程互斥、同步、前驱关系</h2><h3 id="互斥-1"><a href="#互斥-1" class="headerlink" title="互斥"></a>互斥</h3><p>设置一个互斥信号量<code>mutex</code>,然后将各个进程访问该资源的临界区置于<code>wait(mutex)</code>和<code>signal(mutex)</code>之间。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">wait</span>(mutex);</span><br><span class="line">        临界区；</span><br><span class="line">        <span class="built_in">signal</span>(mutex);</span><br><span class="line">        剩余区；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">wait</span>(mutex);</span><br><span class="line">        临界区；</span><br><span class="line">        <span class="built_in">signal</span>(mutex);</span><br><span class="line">        剩余区；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait和mutex应该是成对出现的。</p>
<ul>
<li>缺少wait：导致系统混乱。</li>
<li>缺少signal：导致临界资源无法被释放，进程饥饿。</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>假设有以下两组代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    block <span class="number">1</span>;</span><br><span class="line">    block <span class="number">2</span>;</span><br><span class="line">    block <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">    block <span class="number">4</span>;</span><br><span class="line">    block <span class="number">5</span>;</span><br><span class="line">    block <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步的要求是希望他们能实现一前一后地执行。也就是 142536<br>其方法是：</p>
<ol>
<li>令<code>mutex = 0</code></li>
<li>在前操作之后执行<code>signal(S)</code></li>
<li>在后操作之前执行<code>wait(S)</code></li>
</ol>
<h3 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h3><p>前驱和同步类似，只要：<br>2. 在前操作之后执行<code>signal(S)</code><br>3. 在后操作之前执行<code>wait(S)</code><br>即可。</p>
<ol>
<li>位每一对前驱关系各设置一个同步变量</li>
<li>在前操作之后执行V</li>
<li>在后操作之前执行P</li>
</ol>
<h1 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h1><p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。<br>.<br>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p>
<h1 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h1><p>三个吸烟者在一个房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴，供应 者有丰富货物提供。三个吸烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。供应者随机地将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再把两样东西放在桌子上，唤醒另一个吸烟者。试用信号量和P、 V操作求解该问题</p>
<h1 id="读者–写者问题"><a href="#读者–写者问题" class="headerlink" title="读者–写者问题"></a>读者–写者问题</h1><h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><p>有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。</p>
<p>在圆桌上有五个碗和五支筷子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕，放下筷子又继续思考。</p>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>是一种更加高级的进程互斥/同步关系。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol>
<li>共享数据结构</li>
<li>对数据结构进行操作的一组过程</li>
<li>对局部莞城的共享数据设置初值的语句</li>
<li>有一个名字</li>
</ol>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ol>
<li>局部于冠城的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>一种循环等待的现象，每个进程都在等待对方手里的资源，导致各个进程都处于阻塞过程，无法向前推进。</p>
<h2 id="死锁，饥饿和死循环"><a href="#死锁，饥饿和死循环" class="headerlink" title="死锁，饥饿和死循环"></a>死锁，饥饿和死循环</h2><p>饥饿：长期得不到想要的资源，导致进程无法推进<br>死循环：某进程执行过程中一直挑不出某个循环的现象。</p>
<h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><ol>
<li>互斥条件</li>
<li>不剥夺条件：进程不会被其他进程强行夺走</li>
<li>请求和保持条件：进程保持了至少一个资源，但提出了新的资源请求</li>
<li>循环等待条件：每一个进程以获得的资源都在同时被下一个进程所请求。<br>发生死锁时一定有循环等待，但发生循环等待时未必发生死锁。</li>
</ol>
<h2 id="死锁发生的场合"><a href="#死锁发生的场合" class="headerlink" title="死锁发生的场合"></a>死锁发生的场合</h2><ol>
<li>系统资源的竞争</li>
<li>进程推进顺序非法</li>
<li>信号量使用不当<br>总结——不可剥夺资源的不合理分配。</li>
</ol>
<h2 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a>预防策略</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>采用SPOOLing技术，把独占的设备在逻辑上改造成为共享设备。在进程和设备之间有一个输出进程进行调度。<br>策略的缺点：并不是所有的资源都可以这么改造。互斥性可能是为了系统安全保证的</p>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><ol>
<li>进程请求新的资源得不到满足时，必须释放所有的资源，之后再去申请</li>
<li>进程需要资源时，从其他进程那里强行剥夺。但这种方式一般时需要考虑各个进程的优先级的。<br>策略的缺点：</li>
<li>实现起来比较复杂</li>
<li>释放资源可能会造成前一阶段工作的失效</li>
<li>反复申请和释放资源会增加系统开销，降低系统吞吐量</li>
</ol>
<h3 id="破坏请求保持条件"><a href="#破坏请求保持条件" class="headerlink" title="破坏请求保持条件"></a>破坏请求保持条件</h3><p>采用静态分配方法。进程在运行前一次申请完全部资源，在这个过程中，进程不会请求其他资源，也不会被其他资源请求。<br>缺点： 造成严重的资源浪费，也可能导致饥饿</p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>采用顺序资源分配法。每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完毕。<br>缺点：</p>
<ol>
<li>不方便增加新的设备</li>
<li>进程实际上的资源顺序可能和编号递增顺序不一致</li>
<li>给用户造成麻烦</li>
</ol>
<h2 id="避免策略"><a href="#避免策略" class="headerlink" title="避免策略"></a>避免策略</h2><h3 id="安全序列方法"><a href="#安全序列方法" class="headerlink" title="安全序列方法"></a>安全序列方法</h3><p>系统按照这样的序列分配资源，那么每个进程都能够顺利完成，只要能找到安全序列，系统就是安全状态。<br>反之，如果安全序列找不到，系统就进入了不安全状态，也就是说所有进程都可能无法顺利地执行下去。</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><h2 id="检测和解除方法"><a href="#检测和解除方法" class="headerlink" title="检测和解除方法"></a>检测和解除方法</h2><h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><p>把资源分配</p>
<h3 id="解除方法"><a href="#解除方法" class="headerlink" title="解除方法"></a>解除方法</h3><ol>
<li>资源剥夺法：挂起死锁进程，并抢占资源</li>
<li>撤销进程法：强者撤销死锁进程</li>
<li>进程回退法：</li>
</ol>
<p>决定操作对象：</p>
<ol>
<li>进程优先级</li>
<li>执行时间</li>
<li>剩余时间</li>
<li>进程使用的资源数量</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/26/memory-note-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/26/memory-note-1/" class="post-title-link" itemprop="url">内存的管理模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-26 16:51:28 / Modified: 17:01:23" itemprop="dateCreated datePublished" datetime="2021-06-26T16:51:28+08:00">2021-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h1><h2 id="内存空间的分配和回收"><a href="#内存空间的分配和回收" class="headerlink" title="内存空间的分配和回收"></a>内存空间的分配和回收</h2><p>内存管理的内容：</p>
<ol>
<li>空闲和占用内存的记录</li>
<li>新进程的占用位置 ——地址转换功能</li>
<li>内存空间的回收</li>
</ol>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><ol>
<li>设置一对上下限寄存器，存放进程的上下限地址，以检查是否越界。</li>
<li>采用重定位寄存器和界地址寄存器进行越界检查。重定位——起始物理地址；界地址寄存器——最大逻辑地址。</li>
</ol>
<h2 id="内存的覆盖和交换"><a href="#内存的覆盖和交换" class="headerlink" title="内存的覆盖和交换"></a>内存的覆盖和交换</h2><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>解决程序大小超过物理内存综合的问题。将程序分为多个段，常用的段常驻内存；不常用的段在需要时调入内存。<br>但是操作系统是无法得知程序本身的调用结构的。程序员必须要自己声明这个覆盖结构才行。</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>也成为兑换技术，内存空间紧张的时候，系统会将其中一些进程暂时换出外村，把外存，把某些已经具备运行条件的进程换入内存。这是一种中级调度模式。<br>进程的PCB需要常驻内存。<br>这样就引入了进程的七状态模型。</p>
<h4 id="调度的位置"><a href="#调度的位置" class="headerlink" title="调度的位置"></a>调度的位置</h4><p>在具有对换功能的操作系统里，磁盘空间分为文件区和对换区。后者主要追求换入\换出速度，这样就采用了连续分配方式。<br>调度主要发生在对换区当中。</p>
<h4 id="调度的时机"><a href="#调度的时机" class="headerlink" title="调度的时机"></a>调度的时机</h4><p>交换通常仅在多个进程运行并且内存吃紧的情况下发生。例如缺页率过高，说明内存紧张。</p>
<h4 id="调度的主体"><a href="#调度的主体" class="headerlink" title="调度的主体"></a>调度的主体</h4><p>优先换出：</p>
<ol>
<li>阻塞进程</li>
<li>优先级比较低的进程。</li>
<li>也可能会考虑进程的驻留时间<br>PCB不会被换出外存，它是常驻内存的。</li>
</ol>
<h3 id="覆盖和交换的区别"><a href="#覆盖和交换的区别" class="headerlink" title="覆盖和交换的区别"></a>覆盖和交换的区别</h3><ol>
<li>覆盖是在同一个程序或者进程中的</li>
<li>交换是发生在进程和进程之间的。</li>
</ol>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>内存被分为系统区和用户区，内存只能有一道用户程序。用户程序独占了整个用户区。</p>
<p>优点：</p>
<ol>
<li>实现简单，没有外部碎片</li>
</ol>
<p>缺点：</p>
<p>会产生内部碎片，只能用于单用户单任务操作系统中。存储器利用率比较低。</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>把用户空间划分为若干个固定大小的分区，在每个分区值装入一道作业。</p>
<ol>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ol>
<p>用一台计算机控制多个相同的对象的场合。操作系统需要建立一个分区说明表，来实现各个分区的分配和回收。<br>每个表象对应一个分区，通常按照分区大小排列，这些包括了分区的大小，起始地址和状态。</p>
<p>优点：没有外部碎片</p>
<p>缺点：用户程序太大的时候，只能采用覆盖技术，同时也会产生内部碎片</p>
<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>进程在装入内存的时候，会根据进程的大小动态地建立分区，并使得分区的大小正好适合进程的需要。这个时候，分区的大小和数目是可变的。</p>
<h3 id="记录内存和使用情况"><a href="#记录内存和使用情况" class="headerlink" title="记录内存和使用情况"></a>记录内存和使用情况</h3><h4 id="空闲分区表"><a href="#空闲分区表" class="headerlink" title="空闲分区表"></a>空闲分区表</h4><p>每个空闲分区对应了一个表项，表项中包含着<strong>分区号、分区大小和分区起始信息</strong>等地址。</p>
<h4 id="空闲分区链"><a href="#空闲分区链" class="headerlink" title="空闲分区链"></a>空闲分区链</h4><p>每个分区的起始部分和末尾部分分别设置了<strong>前向指针</strong>和<strong>后向指针</strong>。起始部分同时可以记录分区大小等信息。</p>
<h3 id="空闲分区的分配"><a href="#空闲分区的分配" class="headerlink" title="空闲分区的分配"></a>空闲分区的分配</h3><p>采用<strong>动态分区分配算法</strong>。</p>
<h3 id="动态分区的分配和回收"><a href="#动态分区的分配和回收" class="headerlink" title="动态分区的分配和回收"></a>动态分区的分配和回收</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>没有内部碎片，但是有外部碎片。<br><strong>内部碎片</strong> ： 分配给某个进程的内存区域里，某些部分没有用上。<br><strong>外部碎片</strong> ： 内存中的某些空闲分区因为太小而难以利用。<br>可以采用紧凑技术来解决外部碎片。</p>
<h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><h3 id="首次适应"><a href="#首次适应" class="headerlink" title="首次适应"></a>首次适应</h3><p>从低地址查找，找到第一个能够满足大小的空闲分区。<br>空闲分区以地址递增的次序排列。每次分配内存是顺序查找空闲分区链或者表。</p>
<h3 id="最佳适应"><a href="#最佳适应" class="headerlink" title="最佳适应"></a>最佳适应</h3><p>找到符合进程要求，且体积最小的空闲区域。<br>空闲分区按照容量递增次序链接，每次分配内存的时候顺序查找空闲分区链，找到大小能够满足的第一个空闲分区。<br>但是这种方法会留下越来越多的外部碎片。</p>
<h3 id="最坏适应"><a href="#最坏适应" class="headerlink" title="最坏适应"></a>最坏适应</h3><p>每次分配时，优先采用最大的连续空闲区。空闲分区按照容量递减的次序进行链接。<br>但是这会导致大分区很快被用完。如果大进程后到达，就不会有内存分区可用了。</p>
<h3 id="邻近适应"><a href="#邻近适应" class="headerlink" title="邻近适应"></a>邻近适应</h3><p>每次从上次查找的结束位置开始检索。<br>空闲分区以地址递增的顺序循环排列，每次分配内存的时候从上次查找结束的位置开始查找空闲分区链或者空闲分区表。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>首次适应方法效果最好。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>空闲分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应</td>
<td>从头到尾寻找合适的分区</td>
<td>地址递增</td>
<td>综合看来性能最好，算法开销最小。</td>
<td></td>
</tr>
<tr>
<td>最佳适应</td>
<td>小分区优先</td>
<td>容量递增</td>
<td>更多的大分区得以保留下来以满足大进程的需求</td>
<td>容易产生很多太小的碎片。回收分区后需要对空闲分区队列重新排序。</td>
</tr>
<tr>
<td>最坏适应</td>
<td>大分区优先</td>
<td>容量递减</td>
<td>减少了难以利用的小碎片</td>
<td>大进程用得太快，算法开销大</td>
</tr>
<tr>
<td>临近适应</td>
<td>每次从上次结束的位置开始查找</td>
<td>地址递增，循环链表</td>
<td>算法开销小</td>
<td>会使得高地址大分区被快速用完。</td>
</tr>
</tbody></table>
<h1 id="基本分页管理系统"><a href="#基本分页管理系统" class="headerlink" title="基本分页管理系统"></a>基本分页管理系统</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/26/LRU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/26/LRU/" class="post-title-link" itemprop="url">LRU算法及其实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-26 13:21:04 / Modified: 18:13:00" itemprop="dateCreated datePublished" datetime="2021-06-26T13:21:04+08:00">2021-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/26/sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/26/sort/" class="post-title-link" itemprop="url">排序算法及总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-26 13:14:08" itemprop="dateCreated datePublished" datetime="2021-06-26T13:14:08+08:00">2021-06-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:10:31" itemprop="dateModified" datetime="2021-06-27T22:10:31+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>统一命名：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void sort(elementType A[],int N);</span><br></pre></td></tr></table></figure><br>排序的稳定性：任意两个相等的数据，排序前后的相对位置不发生改变</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>对每个数组元素相邻的元素进行比较，若当前元素顺序错误，则调换该元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(elementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> P=A.<span class="built_in">size</span>()<span class="number">-1</span>;P&gt;=<span class="number">0</span>;P--)&#123; <span class="comment">//整趟冒泡从0到N结束</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;    <span class="comment">//这是一趟冒泡，从0到倒数第i个元素开始。</span></span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">break</span>;    <span class="comment">//这一趟没有交换，直接跳出循环。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其时间复杂度为O(N2)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(elementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;N;p++)&#123;</span><br><span class="line">        elementType spear = A[p];<span class="comment">//摸牌</span></span><br><span class="line">        <span class="keyword">int</span> i;                  <span class="comment">//需要插入的牌的编号</span></span><br><span class="line">        <span class="keyword">for</span>(i=P ; i&gt;<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]&gt;spear ; i--)&#123;</span><br><span class="line">            A[i] =  A[i<span class="number">-1</span>];     <span class="comment">//向后移位，为摸牌做准备</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[i] = spear;   <span class="comment">//新牌落位</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为O（N2），具有稳定性</p>
<h2 id="时间复杂堆下界"><a href="#时间复杂堆下界" class="headerlink" title="时间复杂堆下界"></a>时间复杂堆下界</h2><p>对于下表i,j，若A[i]&gt;A[j],那么(i,j)是一对逆序对。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>Donald Shell提出的排序算法              </p>
<ul>
<li>插排每次只会交换相邻的两个元素，效率较低。      </li>
<li>先对子序列进行一次排序。——间隔N次数组进行排序       </li>
<li>然后对下一个子序列进行排序。        </li>
<li>接下来再减小N,对排序得到的子序列再做一次操作。</li>
<li>最后做一次1间隔排序</li>
</ul>
<ol>
<li>定义增量序列{D_M}</li>
<li>对每个D_k进行一次D_k间隔排序。，更小间隔的排序不会破坏上一次排序的有序性。<h3 id="原始希尔排序"><a href="#原始希尔排序" class="headerlink" title="原始希尔排序"></a>原始希尔排序</h3>构造增量序列:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D_m = [N/2],D_k =[D_&#123;k+1&#125;/2]</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(elementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> D=N/<span class="number">2</span>;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>)&#123;        <span class="comment">//构造增量序列</span></span><br><span class="line">        <span class="comment">//进行一次插入排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> P = D;P&lt;N;P++)&#123;</span><br><span class="line">            elementType spear=A[P];</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=P;i&gt;=D&amp;&amp;A[i<span class="number">-1</span>]&gt;spear;i-=D)&#123;       <span class="comment">//每隔D进行一次排序</span></span><br><span class="line">                A[i]= A[i-D];</span><br><span class="line">            &#125;</span><br><span class="line">            A[i] = spear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度为<code>$\Theta(N^2)$</code><br>问题在于增量序列的选取上。增量元素应该互质，小增量在排序中可能不起作用。<h3 id="基于其他的增量序列的排序算法"><a href="#基于其他的增量序列的排序算法" class="headerlink" title="基于其他的增量序列的排序算法"></a>基于其他的增量序列的排序算法</h3></li>
<li>Hibbard增量序列<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D_k = 2^k-1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Theta(N^&#123;3/2&#125;)</span><br></pre></td></tr></table></figure></li>
<li>Sedgewick增量序列<br>{1,5,19,41,199,…};</li>
</ol>
<script type="math/tex; mode=display">T_{avg}=O(N^{7/6})</script><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">(elementType A[], <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        MinPosition= <span class="built_in">ScanForMin</span>(A,i,N<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//寻找最小元</span></span><br><span class="line">        <span class="built_in">Swap</span>(A[i],A[MinPosition]);</span><br><span class="line">        <span class="comment">//将未排序部分的最小元替换到有序部分的最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T=\Theta(N^2)</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种利用最小堆实现最小元的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(elementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    minheap&lt;elementType&gt; heap;</span><br><span class="line">    heap.<span class="built_in">bulid</span>(A);                      <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">        tmpA[i] = <span class="built_in">deleteMin</span>(A);         <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        A[i] = tmpA[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="归并过程"><a href="#归并过程" class="headerlink" title="归并过程"></a>归并过程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(elementType A[],elementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LeftEnd =R<span class="number">-1</span>;               <span class="comment">//左侧重点位置      </span></span><br><span class="line">    <span class="keyword">int</span> tmp = L;                    <span class="comment">//结果数组的位置</span></span><br><span class="line">    <span class="keyword">int</span> num = rightEnd -L+<span class="number">1</span>;        </span><br><span class="line">    <span class="keyword">while</span>(L&lt;=lLeftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R]) TmpA[tmp++] =A[L++];</span><br><span class="line">        <span class="keyword">else</span>  TmpA[tmp++] = A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左边剩余位置</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=LeftEnd)&#123;</span><br><span class="line">        TmpA[tmp++] =  A[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)&#123;</span><br><span class="line">        TmpA[tmp++] = A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++,RightEnd--)&#123;</span><br><span class="line">        A[RightEnd]  = TmpA[RightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于归并过程的归并算法"><a href="#基于归并过程的归并算法" class="headerlink" title="基于归并过程的归并算法"></a>基于归并过程的归并算法</h3><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(elementType A[],elementType tmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> rightEnd)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> center;</span><br><span class="line">   <span class="comment">//边界条件</span></span><br><span class="line">   <span class="keyword">if</span>(L&lt;rightEnd)&#123;</span><br><span class="line">       center = (L+RightEnd)/<span class="number">2</span>;</span><br><span class="line">       <span class="comment">//先排左右</span></span><br><span class="line">       <span class="built_in">mergeSort</span>(A,tmpA,L,center);</span><br><span class="line">       <span class="built_in">mergeSort</span>(A,tmpA,center+<span class="number">1</span>,RightEnd);</span><br><span class="line">       <span class="comment">//再去归并</span></span><br><span class="line">       <span class="built_in">merge</span>(A,tmpA,center+<span class="number">1</span>,RightEnd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uniMergSort</span><span class="params">(elementTypeA[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    elementType *TmpA = <span class="built_in">malloc</span>(N*<span class="built_in"><span class="keyword">sizeof</span></span>(elementType));</span><br><span class="line">    <span class="keyword">if</span>(TmpA!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,TmpA,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Error</span>(<span class="string">&quot;no space.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最外层声明临时数组TmpA，有助于减少反复内存申请的现象。</p>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) <span class="comment">// 从右向左找第一个小于x的数</span></span><br><span class="line">                j--;  </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt; x) <span class="comment">// 从左向右找第一个大于等于x的数</span></span><br><span class="line">                i++;  </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        <span class="built_in">quick_sort</span>(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        <span class="built_in">quick_sort</span>(s, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己写的版本：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">      <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">      <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">          <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">          <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">          <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">swap</span>(arr[i], arr[l]);</span><br><span class="line">      <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">      <span class="built_in">quickSort</span>(arr, l, i - <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">quickSort</span>(arr, i + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><br>带随机选择哨兵的版本：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomized_partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l; <span class="comment">// 随机选一个作为我们的主元</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">randomized_quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="built_in">randomized_partition</span>(nums, l, r);</span><br><span class="line">            <span class="built_in">randomized_quicksort</span>(nums, l, pos - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">randomized_quicksort</span>(nums, pos + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">randomized_quicksort</span>(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://img-blog.csdnimg.cn/20190219081232815.png" alt="image"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> maxNum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> minNum = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(num,max);</span><br><span class="line">        minNum = <span class="built_in">min</span>(num,min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (maxNum-minNum) / num.<span class="built_in">size</span>() +<span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; bucket;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> bucketIndex = (num - minNum)/num.<span class="built_in">size</span>();</span><br><span class="line">        bucket[bucketIndex].<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个桶内进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(),bucket[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桶内元素进行还原</span></span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bucket[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            num[ind ++ ] = bucket[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27124771/article/details/87651495">https://blog.csdn.net/qq_27124771/article/details/87651495</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="image"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/25/About-me/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/25/About-me/" class="post-title-link" itemprop="url">About me</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-06-25 22:39:24 / Modified: 22:49:06" itemprop="dateCreated datePublished" datetime="2021-06-25T22:39:24+08:00">2021-06-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/25/about/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/25/about/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-25 22:32:07" itemprop="dateCreated datePublished" datetime="2021-06-25T22:32:07+08:00">2021-06-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-24 17:58:29" itemprop="dateModified" datetime="2021-06-24T17:58:29+08:00">2021-06-24</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/25/Trie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/25/Trie/" class="post-title-link" itemprop="url">Trie树的概念和构建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-25 22:23:16" itemprop="dateCreated datePublished" datetime="2021-06-25T22:23:16+08:00">2021-06-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-26 18:12:37" itemprop="dateModified" datetime="2021-06-26T18:12:37+08:00">2021-06-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一种查找树，用来存储和查找对应的单词。查找树上从根节点到叶节点的每个路径都可以用来表示一个单词。</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>一般包括如下的几个操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span></span>;   <span class="comment">//插入字符串word；</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span></span>;   <span class="comment">//寻找word是否在字典树中</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startWith</span><span class="params">(string prefix)</span><span class="comment">//寻找prefix是不是前缀</span></span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="子节点的设计"><a href="#子节点的设计" class="headerlink" title="子节点的设计"></a>子节点的设计</h2><p>每个子节点应该包括两个元素：</p>
<ol>
<li>指向子节点的指针数组<code>children</code>,也就是<code> vector<Trie*> children;</code></li>
<li>用来表示是否到达字符串结尾的布尔型常量<code>bool isEnd</code>.<h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2>初始化根节点的两个对应变量即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Trie</span>()&#123;</span><br><span class="line">    children.<span class="built_in">reshape</span>(<span class="number">26</span>);</span><br><span class="line">    isEnd = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
或者写成：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Trie</span>():<span class="built_in">children</span>(<span class="number">26</span>),<span class="built_in">isEnd</span>(<span class="literal">false</span>)&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2>从根节点插入字符串。那么存在两个情况：</li>
<li>子节点存在。那么沿着指针移动到新的子节点，继续处理下一个字符</li>
<li>子节点不存在，创建新的子节点，并记录在children上。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Trie:: <span class="built_in">insert</span>(string word)&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch: word)&#123;</span><br><span class="line">        ch -=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;children[ch] == <span class="literal">nullptr</span>)&#123;  <span class="comment">//对应情况2</span></span><br><span class="line">            node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();    <span class="comment">//建立一个空节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[ch];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isEnd = <span class="literal">true</span>;     <span class="comment">//该字符串已经结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找前缀"><a href="#寻找前缀" class="headerlink" title="寻找前缀"></a>寻找前缀</h2>查找。从根开始查找前缀。同样有两个情况：</li>
<li>子节点存在，继续向下处理下一个字符。<code>node = node-&gt;children[ch]</code></li>
<li>子节点不存在，匹配失败。直接返回空指针<br>如果前缀末尾对应的节点的isEnd值为真，那么说明字典树中有这个字符串。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Trie::Trie* <span class="title">seachPrefix</span><span class="params">(string prefix)</span></span>&#123;</span><br><span class="line">    Trie* node = thisl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> ch:prefix)&#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; children[ch] == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[ch];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">Trie:: <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">    Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">    <span class="comment">//要保证找到的这个节点真的记录了一个完整的单词，否则就会出现寻找hell而找到hello的情况</span></span><br><span class="line">    <span class="keyword">return</span> node!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line">Trie:: <span class="function"><span class="keyword">bool</span> <span class="title">startwith</span><span class="params">(string prefix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(string word)!=<span class="literal">nullptr</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/25/DP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/25/DP/" class="post-title-link" itemprop="url">动态规划简述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-25 22:23:16" itemprop="dateCreated datePublished" datetime="2021-06-25T22:23:16+08:00">2021-06-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:10:55" itemprop="dateModified" datetime="2021-06-27T22:10:55+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[toc]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>已知问题规模为n的前提A，求解一个未知解B。（我们用An表示“问题规模为n的已知条件”）</p>
<p>此时，如果把问题规模降到0，即已知A0，可以得到A0-&gt;B.<br>如果从A0添加一个元素，得到A1的变化过程。即A0-&gt;A1; 进而有A1-&gt;A2; A2-&gt;A3; …… ; Ai-&gt;Ai+1.<br>这就是严格的归纳推理，也就是我们经常使用的数学归纳法；<br>对于Ai+1，只需要它的上一个状态Ai即可完成整个推理过程（而不需要更前序的状态）。我们将这一模型称为马尔科夫模型。对应的推理过程叫做“贪心法”。<br>然而，Ai与Ai+1往往不是互为充要条件，随着i的增加，有价值的前提信息越来越少，我们无法仅仅通过上一个状态得到下一个状态，因此可以采用如下方案：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;A1-&gt;A2&#125;; &#123;A1, A2-&gt;A3&#125;; &#123;A1,A2,A3-&gt;A4&#125;;……; &#123;A1,A2,...,Ai&#125;-&gt;Ai+1.</span><br></pre></td></tr></table></figure></p>
<p>这种方式就是第二数学归纳法。<br>对于Ai+1需要前面的所有前序状态才能完成推理过程。我们将这一模型称为高阶马尔科夫模型。对应的推理过程叫做“动态规划法”。            </p>
<h2 id="能用动规解决的问题的特点"><a href="#能用动规解决的问题的特点" class="headerlink" title="能用动规解决的问题的特点"></a>能用动规解决的问题的特点</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>(1) <strong>最优化原理</strong>：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。<br>(2) <strong>无后效性</strong>：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。<br>(3)<strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<h2 id="动规解题的一般思路"><a href="#动规解题的一般思路" class="headerlink" title="动规解题的一般思路"></a>动规解题的一般思路</h2><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</span><br></pre></td></tr></table></figure>
<p>(1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。<br>(2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。<br>(3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。<br>(4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。<br>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>（1）分析最优解的性质，并刻画其结构特征。</p>
<p>（2）递归的定义最优解。</p>
<p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p>
<p>（4）根据计算最优值时得到的信息，构造问题的最优解</p>
<h2 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a>算法实现的说明</h2><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p> 使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>（1）问题的阶段 （2）每个阶段的状态</p>
<p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p>
<p> 递关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法实现的步骤"><a href="#算法实现的步骤" class="headerlink" title="算法实现的步骤"></a>算法实现的步骤</h2><p>1、创建一个一维数组或者二维数组，保存每一个子问题的结果，具体创建一维数组还是二维数组看题目而定，基本上如果题目中给出的是一个一维数组进行操作，就可以只创建一个一维数组，如果题目中给出了两个一维数组进行操作或者两种不同类型的变量值，比如背包问题中的不同物体的体积与总体积，找零钱问题中的不同面值零钱与总钱数，这样就需要创建一个二维数组。</p>
<p>注：需要创建二维数组的解法，都可以创建一个一维数组运用滚动数组的方式来解决，即一位数组中的值不停的变化，后面会详细徐叙述</p>
<p>2、设置数组边界值，一维数组就是设置第一个数字，二维数组就是设置第一行跟第一列的值，特别的滚动一维数组是要设置整个数组的值，然后根据后面不同的数据加进来变幻成不同的值。</p>
<p>3、找出状态转换方程，也就是说找到每个状态跟他上一个状态的关系，根据状态转化方程写出代码。</p>
<p>4、返回需要的值，一般是数组的最后一个或者二维数组的最右下角。</p>
<p>代码基本框架：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">    xn[j] = 初始值;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">      xi[j]=j=max（或min）&#123;<span class="built_in">g</span>(xi-[j1:j2]), ......, <span class="built_in">g</span>(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"> </span><br><span class="line"> t = <span class="built_in">g</span>(x1[j1:j2]); <span class="comment">//</span></span><br><span class="line"> 由子问题的最优解求解整个问题的最优解的方案</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">print</span>(x1[j1]);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line"> &#123;  </span><br><span class="line">      t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=<span class="built_in">f</span>(i); j=j+<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">              <span class="keyword">break</span>;&#125;</span><br></pre></td></tr></table></figure><br>下面通过几个典型例子，从简单到难帮助我们理解动态规划。</p>
<h3 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h3><p>斐波那契数列大家都很熟悉，而且知道用递归可以很容易的做出来<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">solutionFibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">solutionFibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>如果用动态规划，就是把结果存到一个数组中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solutionFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> result[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">			result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				result[i] = result[i-<span class="number">1</span>] + result[i-<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result[n];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><br>与之类似的还有：跳台阶问题：每次只能跳一个或者两个台阶，跳到n层台阶上有几种方法</p>
<p>填充长方体问题：将一个2*1的长方体填充到2*n的长方体中，有多少种方法</p>
<h3 id="2、数组最大不连续递增子序列"><a href="#2、数组最大不连续递增子序列" class="headerlink" title="2、数组最大不连续递增子序列"></a>2、数组最大不连续递增子序列</h3><p>arr[] = {3,1,4,1,5,9,2,6,5}的最长递增子序列长度为4。即为：1,4,5,9</p>
<p>设置一个数组temp，长度为原数组长度，数组第i个位置上的数字代表0…i上最长递增子序列，当增加一个数字时，最大递增子序列可能变成前面最大的递增子序列+1，也可能就是前面最大递增子序列，这需要让新增加进来的数字arr[i]跟前面所有数字比较大小，即当 arr[i] &gt; arr[j]，temp[i] = max{temp[j]}+1，其中，j 的取值范围为：0,1…i-1，当 arr[i] &lt; arr[j]，temp[i] = max{temp[j]}，j 的取值范围为：0,1…i-1，所以在状态转换方程为temp[i]=max{temp[i-1], temp[i-1]+1}<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxChildArrayOrder</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = a.length;</span><br><span class="line">		<span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//temp[i]代表0...i上最长递增子序列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			temp[i] = <span class="number">1</span>;<span class="comment">//初始值都为1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i]&gt;a[j]&amp;&amp;temp[j]+<span class="number">1</span>&gt;temp[i])&#123;</span><br><span class="line">					<span class="comment">//如果有a[i]比它前面所有的数都大，则temp[i]为它前面的比它小的数的那一个temp+1取得的最大值</span></span><br><span class="line">					temp[i] = temp[j]+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> max = temp[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">//从temp数组里取出最大的值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp[i]&gt;max)&#123;</span><br><span class="line">				max = temp[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、数组最大连续子序列和"><a href="#3、数组最大连续子序列和" class="headerlink" title="3、数组最大连续子序列和"></a>3、数组最大连续子序列和</h3><p>如arr[] = {6,-1,3,-4,-6,9,2,-2,5}的最大连续子序列和为14。即为：9,2,-2,5</p>
<p>创建一个数组a，长度为原数组长度，不同位置数字a[i]代表0…i上最大连续子序列和，a[0]=arr[0]设置一个最大值max，初始值为数组中的第一个数字。当进来一个新的数字arr[i+1]时，判断到他前面数字子序列和a[i]+arr[i+1]跟arr[i+1]哪个大，前者大就保留前者，后者大就说明前面连续数字加起来都不如后者一个新进来的数字大，前面数字就可以舍弃，从arr[i+1]开始，每次比较完都跟max比较一下，最后的max就是最大值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxContinueArraySum</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = a.length;</span><br><span class="line">		<span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> sum = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			sum = Math.max(sum+a[i], a[i]);</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;=max)&#123;</span><br><span class="line">				max = sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>4、数字塔从上到下所有路径中和最大的路径</p>
<p>数字塔是第i行有i个数字组成，从上往下每个数字只能走到他正下方数字或者正右方数字，求数字塔从上到下所有路径中和最大的路径，如有下数字塔<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br><span class="line">1    5</span><br><span class="line"></span><br><span class="line">8    4    3</span><br><span class="line"></span><br><span class="line">2    6    7    9</span><br><span class="line"></span><br><span class="line">6    2    3    5    1</span><br></pre></td></tr></table></figure><br>最大路径是3-5-3-9-5，和为25。我们可以分别从从上往下看跟从下往上看两种动态规划的方式去解这个题</p>
<p>从上往下看：当从上往下看时，每进来新的一行，新的一行每个元素只能选择他正上方或者左左方的元素，也就是说，第一个元素只能连他上方的元素，最后一个元素只能连他左上方的元素，其他元素可以有两种选择，所以需要选择加起来更大的那一个数字，并把这个位置上的数字改成相应的路径值，具体过程如下图所示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3                            3                            3                            3</span><br><span class="line"></span><br><span class="line">1    5                      4    8                      4    8                      4    8</span><br><span class="line"></span><br><span class="line">8    4    3                8    4    3                12   12  11             12   12   11  </span><br><span class="line"></span><br><span class="line">2    6    7    9          2    6    7    9           2    6    7    9         14   18   19   20</span><br><span class="line"></span><br><span class="line">6    2    3    5    1    6    2    3    5    1     6    2    3    5    1    20   20   22   25   21</span><br></pre></td></tr></table></figure><br>所以最大值就是最底层的最大值也就是25。</p>
<p>具体运算过程就是，建立一个n*n的二维数组dp[][]，n是数字塔最后一行的数字个数，二维数组每一行数字跟数字塔每一行数字个数一样，保存的值是从上方到这一个位置最大路径的值，填入边界值dp[0][0]=3，每一行除了第一个值跟最后一个值，其他的值选择上方或者左上方更大的值与这个位置上的值相加得来的值，即<code>dp[i][j]=max(dp[i-1][j-1], dp[i-1][j]) + n[i][j]</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> n[][])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n.length][n.length];</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = n[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="comment">//如果是第一列，直接跟他上面数字相加</span></span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j] + n[i][j];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">//如果不是第一列，比较他上面跟上面左面数字谁大，谁大就跟谁相加，放到这个位置</span></span><br><span class="line">					dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + n[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">				max = Math.max(dp[i][j], max);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>优化：动态规划中每一个需要创建一个二维数组的解法，都可以换成只创建一个一维数组的滚动数组解法，依据的规则是一般二维数组中存放的是所有的结果，但是一般我们需要的结果实在二维数组的最后一行的某个值，前面几行的值都是为了得到最后一行的值而需要的，所以可以开始就创建跟二维数组最后一行一样大的一维数组，每次存放某一行的值，下一次根据这一行的值算出下一行的值，在存入这个数组，也就是把这个数组滚动了，最后数组存储的结果就是原二维数组中最后一行的值。</p>
<p>拿到本题来说，开始创建一个一维数组dp[n]，初始值只有dp[0]=3，新进来一行时，仍然遵循dp[i][j]=Math.max(dp[i-1][j-1], dp[i-1][j]) + n[i][j]，现在为求dp[j]，所以现在dp[i-1][j]其实就是数组中这个位置本来的元素即dp[j]，而dp[i-1][j-1]其实就是数组中上一个元素dp[j-1]，也就是说dp[j]=Math.max(dp[j], dp[j-1])+n[i][j]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray2</span><span class="params">(<span class="keyword">int</span> n[][])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n.length];</span><br><span class="line">		temp[<span class="number">0</span>] = n[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j==i)&#123;</span><br><span class="line">					temp[i]=temp[i-<span class="number">1</span>]+n[i][j];</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">					temp[<span class="number">0</span>]+=n[i][<span class="number">0</span>];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					temp[j]=Math.max(temp[j], temp[j-<span class="number">1</span>])+n[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> max = temp[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">//从temp数组里取出最大的值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(temp[i]&gt;max)&#123;</span><br><span class="line">				max = temp[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这样空间复杂度就大幅度下降了。</p>
<p>从下往上看时：从下往上看时大体思路跟从上往下看一样，但是要简单一些，因为不用考虑边界数据，从下往上看时，每进来上面一行，上面一行每个数字有两条路径到达下面一行，所以选一条最大的就可以<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">3                            3                            3                           25</span><br><span class="line"></span><br><span class="line">1    5                      1    5                      1    5                     18   22</span><br><span class="line"></span><br><span class="line">8    4    3                8    4    3                17  16  17              17  16  17  </span><br><span class="line"></span><br><span class="line">2    6    7    9          8    9    12  14         8    9   12  14         8    9    12  14</span><br><span class="line"></span><br><span class="line">6    2    3    5    1    6    2    3    5    1     6    2    3    5    1    6    2    3    5    1</span><br><span class="line">````</span><br><span class="line">所以最大值就是最上面数字就是25.</span><br><span class="line">具体方法也是建立一个二维数组，最下面一行数据添到二维数组最后一行，从下往上填数字，所以状态转化方程是dp[i][j]=Math.max(dp[i+1][j+1], dp[i+1][j]) + n[i][j]，具体解决方法跟从上往下看一样，就不写具体代码了。</span><br><span class="line"></span><br><span class="line">优化：滚动数组，只创建一个一维数组，数组初始值是数字塔最下面一行的值，每次新加一行值，将数组中的值改变，最后数组中第一个数字就是最大路径的值。状态转化方程就是temp[j] = Math.max(temp[j], temp[j+1])+n[i][j]。具体代码如下</span><br><span class="line">```java</span><br><span class="line">public static int minNumberInRotateArray3(int n[][]) &#123;</span><br><span class="line">		int[] temp = new int[n.length];</span><br><span class="line">		for(int i=0;i&lt;n.length;i++)&#123;</span><br><span class="line">			temp[i] = n[n.length-1][i];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i=n.length-2;i&gt;=0;i--)&#123;</span><br><span class="line">			for(int j=0;j&lt;=i;j++)&#123;</span><br><span class="line">				temp[j] = Math.max(temp[j], temp[j+1])+n[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return temp[0];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>从下往上看跟从上往下看相比，虽然逻辑较为简单，但是从下往上看时需要得到完整的数字塔之后才能开始计算，而从上往下看时可以随着数字塔的深入来计算，也可以返回任意一层的结果，是最好的方法。</p>
<h3 id="5、两个字符串最大公共子序列"><a href="#5、两个字符串最大公共子序列" class="headerlink" title="5、两个字符串最大公共子序列"></a>5、两个字符串最大公共子序列</h3><p>比如字符串1：BDCABA；字符串2：ABCBDAB，则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p>
<p>具体思想：设 X=(x1,x2,…..xn)和 Y={y1,y2,…..ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)，如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)就好，LCS(X,Y)=LCS(Xn-1，Ym-1)+1；如果xn != ym，这下要麻烦一点，因为它产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)。</p>
<p>动态规划解法：先创建一个解空间即数组，因为给定的是两个字符串即两个一维数组存储的数据，所以要创建一个二维数组，设字符串X有n个值，字符串Y有m个值，需要创建一个m+1*n+1的二维数组，二维数组每个位置（i，j）代表当长度为i的X子串与长度为j的Y的子串他们的最长公共子串，之所以要多创建一个是为了将边界值填入进去，边界值就是第一行跟第一列，指X长度为0或者Y长度为0时，自然需要填0，其他位置填数字时，当这两个位置数字相同，dp[i][j] = dp[i-1][j-1]+1；当这两个位置数字不相同时，dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j])。最后二维数组最右下角的值就是最大子串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTwoArraySameOrder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxTwoArraySameOrderMethod</span><span class="params">(String str1,String str2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = str1.length();</span><br><span class="line">		<span class="keyword">int</span> n = str2.length();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 定义一个二维数组保存公共子序列长度</span></span><br><span class="line"><span class="comment">		 * dp[i][j]表示字符串1从头开始长度是i，字符串2从头开始长度是j，这两个字符串的最长公共子序列的长度</span></span><br><span class="line"><span class="comment">		 * 设置数组行列比他们长度大一往二维数组中填写数字时，每个位置的数字跟他上方或者左方或者左上方数字有关系，这样处理边界数字时不用处理这种情况，方便接下来的循环</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 初始化第一行第一列</span></span><br><span class="line"><span class="comment">		 * dp[0,j]表示啥？表示字符串1的长度是0，字符串2的长度是j，这两个字符串的最长公共子序列的长度是0，因为，字符串1 根本就没有嘛</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 如果当c[i][j]时，字符串1从头开始长度是i，字符串2从头开始长度是j时他们最后一个字符相同</span></span><br><span class="line"><span class="comment">				 * 就同时把他们向前移动一位，找c[i-1][j-1]时长度最大的再加一</span></span><br><span class="line"><span class="comment">				 * 表现在二维数组中就是c[i][j]左上方的点</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 如果当c[i][j]时，他们最后一个字符不相同</span></span><br><span class="line"><span class="comment">					 * 要将str1往前移动一位的c[i-1][j]的lcs长度，或者将str2往前移动一位的c[i][j-1]的lcs长度</span></span><br><span class="line"><span class="comment">					 * 哪个长，将它赋给c[i][j]</span></span><br><span class="line"><span class="comment">					 * 表现在二维数组中就是c[i][j]上方的点或者左方的点</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[m][n];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str1 = <span class="string">&quot;BDCABA&quot;</span>;</span><br><span class="line">		String str2 = <span class="string">&quot;ABCBDAB&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> array = MaxTwoArraySameOrderMethod(str1,str2);</span><br><span class="line">		System.out.println(array);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6、背包问题"><a href="#6、背包问题" class="headerlink" title="6、背包问题"></a>6、背包问题</h3><p>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数），求背包能够容纳的最大价值。</p>
<p>像这种固定数值的组合问题，比如这个问题的W总容量，跟下个实例零钱问题的总钱数，都是适合用动态规划来解决的问题，对于这样的问题，动态规划的解法就是：创建一个二维数组，横坐标是从1开始到W，纵坐标是组成W的各种元素，本题中就是指W1，W2……Wn，数组中每个位置（i，j）的数字就是当组成元素只有W1，W2……Wi，背包可放容量为j时的结果，本题中就是容纳的最大价值。所以很容易分析出，当（i，j）时，如果Wi能放的下，空间减小，但是会增加Pi的价值，如果Wi不能放的下，空间不变，是（i-1，j）的价值，取其中最大值就好了，即状态转化方程为能放的下，dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]]+p[i])；放不下，dp[i][j] = dp[i-1][j]；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PackageHelper</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> w[],<span class="keyword">int</span> p[],<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//设置一个二维数组，横坐标代表从第一个物品开始放到第几个物品，纵坐标代表背包还有多少容量，dp代表最大价值</span></span><br><span class="line">		<span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][v+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=v;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=w[i])&#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 当能放得下这个物品时，放下这个物品，价值增加，但是空间减小，最大价值是dp[i-1][j-w[i]]+p[i]</span></span><br><span class="line"><span class="comment">					 * 当不放这个物品时，空间大，物品还是到i-1，最大价值是dp[i-1][j]</span></span><br><span class="line"><span class="comment">					 * 比较这两个大小，取最大的，就是dp[i][j]</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-w[i]]+p[i]);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">//如果放不下，就是放上一个物品时的dp</span></span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[n][v];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>优化：滚动数组，只创建一个一维数组，长度为从1到W，初始值都是0，能装得下i时，dp[j] = Math.max(dp[j], dp[j-w[i]]+p[i])；装不下时，dp[j] = dp[j];<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">PackageHelper2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> w[],<span class="keyword">int</span> p[],<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//设置一个二维数组，横坐标代表从第一个物品开始放到第几个物品，纵坐标代表背包还有多少容量，dp代表最大价值</span></span><br><span class="line">		<span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[v+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;w[i])&#123;</span><br><span class="line">					dp[j] = Math.max(dp[j], dp[j-w[i]]+p[i]);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[j] = dp[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[v];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7、找零钱问题：有几种方法"><a href="#7、找零钱问题：有几种方法" class="headerlink" title="7、找零钱问题：有几种方法"></a>7、找零钱问题：有几种方法</h3><p>具体思路同背包问题，这里只分析一下动态转化方程，能用这种零钱，分为用了这种零钱的方法跟没用到这种零钱的方法，dp[i][j] = dp[i-1][j] + dp[i][j-num[i]]；如果不能用这种零钱，即所组成的面额小于当前零钱，直接等于不用这种零钱的数值，dp[i][j] = dp[i-1][j]。这里要特别注意的是。1、开始填写二维数组边界值时，第一行是填写只用第一种面额零钱组成相应数额的方法，要注意是总数额除以第一种面额取余为0才能组成，即如果第一种面额为2，不能组成3,5的数额等；2、填写二维数组第一列时，代表到用到面额为i时，剩余数额为0，即只用i就可以组成相应数额，这也是一种方法，所以第一列的值，第一个为0，后面全为1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SmallMoney</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = num.length;</span><br><span class="line">		<span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][target+<span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%num[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="number">0</span>][i] = <span class="number">1</span>;<span class="comment">//第一行数值填写</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//第一列数值填写</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&lt;num[i])&#123;</span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-num[i]];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[m-<span class="number">1</span>][target];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化：动态数组，同背包问题即以上分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SmallMoney2</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = num.length;</span><br><span class="line">		<span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%num[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">				dp[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=num[i])&#123;</span><br><span class="line">					dp[j] = dp[j] + dp[j-num[i]];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[target];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8、找零钱问题：所用面额数量最少"><a href="#8、找零钱问题：所用面额数量最少" class="headerlink" title="8、找零钱问题：所用面额数量最少"></a>8、找零钱问题：所用面额数量最少</h3><p>跟上面思路相同，代码不同点：1、填写边界值时，第一行仍是看取余是不是为0，如果为0，填的是除以它的商，即用了几张。2、填写边界值第一列时，  第一列代表用了这一面额的纸币且剩下的数额为0，代表值用着一种纸币就可以构成这种数额，用的张数应该填到（i，j）处，所以第一列都是0；3、写状态转化方程时，要注意判断，如果数额小于面额，直接等于上一层值，dp[i][j]=dp[i-1][j]；  如果数额等于面额，直接等于1；如果数额大于面额，先判断当用掉一张面额时，使用当前面额的剩余数额处是否有值，和不使用当前面额的剩余数额处是否有值，即当dp[i-1][j]!=0&amp;&amp;dp[i][j-num[i]]!=0即这两处都有值，就看那一个更小，如果不都有，仅仅选择一个有值的就好了，具体见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SmallMoney</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = num.length;</span><br><span class="line">		<span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][target+<span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%num[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">				dp[<span class="number">0</span>][i] = i/num[<span class="number">0</span>];<span class="comment">//填入的是张数</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一列应该为0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&lt;num[i])&#123;</span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == num[i])&#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[i-<span class="number">1</span>][j]!=<span class="number">0</span>&amp;&amp;dp[i][j-num[i]]!=<span class="number">0</span>)&#123;<span class="comment">//当两处都有值，即两种方法都可以组成当前数额，取用的张数更小的</span></span><br><span class="line">						dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-num[i]]+<span class="number">1</span>);</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果不能，取能组成的就好</span></span><br><span class="line">						dp[i][j] = dp[i-<span class="number">1</span>][j]!=<span class="number">0</span>?dp[i-<span class="number">1</span>][j]:dp[i][j-num[i]];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[m-<span class="number">1</span>][target];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>优化：滚动数组，具体思路一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SmallMoney2</span><span class="params">(<span class="keyword">int</span> num[],<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = num.length;</span><br><span class="line">		<span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i%num[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">				dp[i] = i/num[<span class="number">0</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&lt;num[i])&#123;</span><br><span class="line">					dp[j] = dp[j];</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == num[i])&#123;</span><br><span class="line">					dp[j] = <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[j]!=<span class="number">0</span>&amp;&amp;dp[j-num[i]]!=<span class="number">0</span>)&#123;</span><br><span class="line">						dp[j] = Math.min(dp[j], dp[j-num[i]]+<span class="number">1</span>);</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						dp[j] = dp[j]!=<span class="number">0</span>?dp[j]:dp[j-num[i]];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[target];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="动态规划和分治区别："><a href="#动态规划和分治区别：" class="headerlink" title="动态规划和分治区别："></a>动态规划和分治区别：</h2><p><strong>动态规划算法</strong>：它通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</p>
<p><strong>分治法</strong>：若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alberteuler.github.io/not_advanced_ins.github.io/2021/06/24/helloworld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/not_advanced_ins.github.io/images/avatar.jpg">
      <meta itemprop="name" content="Albert -W">
      <meta itemprop="description" content="更不更新看心情">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不先进摸鱼研究所">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/not_advanced_ins.github.io/2021/06/24/helloworld/" class="post-title-link" itemprop="url">湍流|序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-24 18:01:35" itemprop="dateCreated datePublished" datetime="2021-06-24T18:01:35+08:00">2021-06-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-26 13:31:19" itemprop="dateModified" datetime="2021-06-26T13:31:19+08:00">2021-06-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/not_advanced_ins.github.io/categories/%E5%B0%8F%E8%AF%B4/" itemprop="url" rel="index"><span itemprop="name">小说</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><blockquote>
<p>“有了BC效应之后，人们总会幻想，维持和平的唯一方法就是消灭战争。发动大规模的战争将所有与自己意见相左的人全部送进坟墓，这样剩下的人之间就一定能够归于和平。殊不知正是因为BC效应的存在，人才会不断剧烈的分化。哪怕剩下这些人真的能保持最初的和平，他们也会因为不断分化的思想和不断被误解的沟通而再次拿起武器。重复之前的斗争，试图将对方送进地狱。”<br>“人是一种多变的，自私的动物。人类社会同样也是复杂多变的系统。既然无法理解如此复杂的系统，那么就对它保持起码的敬畏。让它保持最低限度的稳定。”</p>
</blockquote>
<p align="right">——《别林斯基-柴门霍夫效应初探》</p>

<h1 id="0"><a href="#0" class="headerlink" title="0"></a>0</h1><p>叶峰总能梦到海。<br>湛蓝色的，一望无际的海。他穿着一身便服站在海边。海浪富有节律地拍打着海岸。他低下头，看到脚下的沙滩呈现出一种灰蒙蒙的淡黄色。时不时的，他能看到海浪卷着发白的泡沫打上沙滩来，留下一两只海螺。<br>他盯着一只鹦鹉螺看。接着他便看到自己仿佛置身于海洋当中。他看到海水随着风流动起来。他告诉自己，海风的速度快一点，就能让海水处于湍流的状态。现在他看到了。他看到海的颜色深了一点，呈现出钴蓝色。大大小小的涡旋在视角内舞蹈着，互相撞击。大的分解成小的，小的会分解地更小，直到最后归于平静，他的视野内只有毫无变化的蓝色。<br>他感到自己的眼睛还在睁着。紧接着是一束束几何图形冲着他飞过来，他听说那是自己的大脑正在执行一段自检程序，只是忘了叫什么。<br>眼前的钴蓝色渐渐溶解，变成了聚合物的黑灰色，还有惨白的日光灯。也许又是抗压液的作用，他告诉自己。接着他从座椅上试图坐起身来，此时《加州之梦》的乐曲正一点点钻入他的耳朵。像金属翅膀的蝴蝶。<br>很少有人能理解他的音乐口味。他也不理解。他很难理解歌词里的场景，满目的黄叶，灰暗的天空究竟是怎样的？儿时的他很少见过真正意义上的天空。殖民设施的穹顶根本不配叫天空，尽管那也是灰色的。至于出了殖民设施，那就只有一个巨大的蓝色弹珠和黑到要吞噬一切的宇宙空间了。<br>叶峰坚信自己对于海洋的记忆正是来源于那个弹珠。<br>“起来了？”三眼坐在他正对面。物资箱挡住了他，因此叶峰只能听见他的声音。“这次梦见的是什么？”他的声音像冰川一样，冷冰冰的，听不出任何感情，但是却意外地让人安心。<br>“海。”叶峰又躺回到座椅上。这次旅行让他感到一丝疲倦。“又是海。”<br>“你见过海吗？”三眼问他。<br>“没有。在地球上出任务那么多次，一次海都没见到。”叶峰把头偏向了舷窗。望着离自己渐行渐远的蓝色弹珠。现在已经变成了一粒嵌在天鹅绒上的蓝水晶了。“矛尖-54-1呼叫“冷泉港”，我们现在在哪？完毕。”<br>““冷泉港”收到。两个小时前刚刚离开GEO，我们现在在MTO。完毕。”<br>“收到。感谢提醒。完毕。”        </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/not_advanced_ins.github.io/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/not_advanced_ins.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/not_advanced_ins.github.io/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/not_advanced_ins.github.io/page/7/">7</a><a class="extend next" rel="next" href="/not_advanced_ins.github.io/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Albert -W</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/not_advanced_ins.github.io/js/comments.js"></script><script src="/not_advanced_ins.github.io/js/utils.js"></script><script src="/not_advanced_ins.github.io/js/motion.js"></script><script src="/not_advanced_ins.github.io/js/schemes/muse.js"></script><script src="/not_advanced_ins.github.io/js/next-boot.js"></script>

  




  





</body>
</html>
